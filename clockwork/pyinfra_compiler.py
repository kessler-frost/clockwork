"""
PyInfra Compiler - Template-based conversion of resources to PyInfra code.
"""

import logging
from pathlib import Path
from typing import Any, Dict, List, Optional

from .settings import get_settings

logger = logging.getLogger(__name__)


class PyInfraCompiler:
    """Compiles resources into PyInfra inventory and deploy files."""

    def __init__(self, output_dir: Optional[Path] = None):
        """
        Initialize the PyInfra compiler.

        Args:
            output_dir: Directory to write PyInfra files (overrides settings/.env)
        """
        settings = get_settings()
        self.output_dir = output_dir or settings.pyinfra_output_dir
        if not isinstance(self.output_dir, Path):
            self.output_dir = Path(self.output_dir)

    def compile(self, resources: List[Any]) -> Path:
        """
        Compile resources to PyInfra deployment files.

        Generates both deploy.py and destroy.py so that destroy can be run
        later without re-loading resources. Resources are expected to be
        fully completed (all required fields populated) before compilation.

        Args:
            resources: List of completed Resource objects

        Returns:
            Path to the PyInfra directory
        """
        logger.info(f"Compiling {len(resources)} resources to PyInfra...")

        # Create output directory
        self.output_dir.mkdir(parents=True, exist_ok=True)

        # Generate inventory file
        inventory_path = self.output_dir / "inventory.py"
        inventory_code = self._generate_inventory()
        inventory_path.write_text(inventory_code)
        logger.info(f"Generated inventory: {inventory_path}")

        # Generate deploy file
        deploy_path = self.output_dir / "deploy.py"
        deploy_code = self._generate_deploy(resources)
        deploy_path.write_text(deploy_code)
        logger.info(f"Generated deploy: {deploy_path}")

        # Generate destroy file (for later use)
        destroy_path = self.output_dir / "destroy.py"
        destroy_code = self._generate_destroy(resources)
        destroy_path.write_text(destroy_code)
        logger.info(f"Generated destroy: {destroy_path}")

        logger.info(f"PyInfra compilation complete: {self.output_dir}")
        return self.output_dir

    def _generate_inventory(self) -> str:
        """Generate PyInfra inventory file (localhost by default)."""
        return '''"""PyInfra inventory - defines target hosts."""

# Local execution - use @local connector
hosts = ["@local"]
'''

    def _generate_pyinfra_header(self, operation_type: str) -> str:
        """Generate PyInfra file header with imports.

        Args:
            operation_type: Type of operation (deploy, destroy, assert)

        Returns:
            Header string with docstring and imports
        """
        return f'''"""PyInfra {operation_type} - generated by Clockwork."""

from pyinfra.operations import files, server, brew, git, crontab, docker
from clockwork.pyinfra_operations import apple_containers

'''

    def _generate_pyinfra_footer(self, operation_type: str) -> str:
        """Generate PyInfra file footer.

        Args:
            operation_type: Type of operation for footer comment

        Returns:
            Footer string with closing comment
        """
        return f'''

# End of {operation_type}
'''

    def _generate_deploy(self, resources: List[Any]) -> str:
        """
        Generate PyInfra deploy.py file with all operations.

        Resources should be fully completed before calling this method.
        Each resource generates its PyInfra code using its own fields directly.

        Args:
            resources: List of completed Resource objects

        Returns:
            Deploy file content as string
        """
        # Header
        deploy_code = self._generate_pyinfra_header("deploy")

        # Generate operations for each resource
        operations = []
        for resource in resources:
            try:
                op_code = resource.to_pyinfra_operations()
                operations.append(op_code)
            except Exception as e:
                logger.error(f"Failed to generate operations for {resource.name}: {e}")
                raise

        # Combine all operations
        deploy_code += "\n".join(operations)

        # Footer
        deploy_code += self._generate_pyinfra_footer("deployment")

        return deploy_code

    def compile_assert(
        self,
        resources: List[Any]
    ) -> Path:
        """
        Compile resources to PyInfra assert files.

        Resources should be fully completed before calling this method.

        Args:
            resources: List of completed Resource objects

        Returns:
            Path to the PyInfra directory
        """
        logger.info(f"Compiling assertions for {len(resources)} resources to PyInfra...")

        # Create output directory
        self.output_dir.mkdir(parents=True, exist_ok=True)

        # Generate inventory file (same as deploy)
        inventory_path = self.output_dir / "inventory.py"
        inventory_code = self._generate_inventory()
        inventory_path.write_text(inventory_code)
        logger.info(f"Generated inventory: {inventory_path}")

        # Generate assert file
        assert_path = self.output_dir / "assert.py"
        assert_code = self._generate_assert(resources)
        assert_path.write_text(assert_code)
        logger.info(f"Generated assert: {assert_path}")

        logger.info(f"PyInfra assert compilation complete: {self.output_dir}")
        return self.output_dir

    def _generate_destroy(self, resources: List[Any]) -> str:
        """
        Generate PyInfra destroy.py file with all destroy operations.

        Resources should be fully completed before calling this method.
        Each resource generates its cleanup code using its own fields directly.

        Args:
            resources: List of completed Resource objects

        Returns:
            Destroy file content as string
        """
        # Header
        destroy_code = self._generate_pyinfra_header("destroy")

        # Generate destroy operations for each resource
        operations = []
        for resource in resources:
            try:
                op_code = resource.to_pyinfra_destroy_operations()
                operations.append(op_code)
            except Exception as e:
                logger.error(f"Failed to generate destroy operations for {resource.name}: {e}")
                raise

        # Combine all operations
        destroy_code += "\n".join(operations)

        # Footer
        destroy_code += self._generate_pyinfra_footer("destroy operations")

        return destroy_code

    def compile_assert_single_resource(
        self,
        resource: Any
    ) -> Path:
        """
        Compile assertions for a single resource to PyInfra assert file.

        This generates a resource-specific assert file (e.g., assert_redis-monitored.py)
        that can be executed independently to check only that resource's health.
        Used by the health checker for per-resource health monitoring.

        Args:
            resource: Single completed Resource object

        Returns:
            Path to the generated assert file
        """
        resource_name = resource.name or resource.__class__.__name__
        logger.debug(f"Compiling assertions for single resource: {resource_name}")

        # Create output directory
        self.output_dir.mkdir(parents=True, exist_ok=True)

        # Generate inventory file (same as deploy)
        inventory_path = self.output_dir / "inventory.py"
        if not inventory_path.exists():
            inventory_code = self._generate_inventory()
            inventory_path.write_text(inventory_code)

        # Generate resource-specific assert file
        assert_filename = f"assert_{resource_name}.py"
        assert_path = self.output_dir / assert_filename
        assert_code = self._generate_assert([resource])  # Reuse existing method with single resource
        assert_path.write_text(assert_code)
        logger.debug(f"Generated {assert_filename}: {assert_path}")

        return assert_path

    def _generate_assert(
        self,
        resources: List[Any]
    ) -> str:
        """
        Generate PyInfra assert.py file with all assertion operations.

        Resources should be fully completed before calling this method.
        Each resource generates its assertion code using its own fields directly.

        Args:
            resources: List of completed Resource objects

        Returns:
            Assert file content as string
        """
        # Header
        assert_code = self._generate_pyinfra_header("assert")

        # Generate assertion operations for each resource
        all_operations = []

        for resource in resources:
            resource_ops = []

            # Add separator comment
            resource_ops.append(f"\n# Assertions for: {resource.name}")

            # Add resource assertions (type-safe BaseAssertion objects only)
            if hasattr(resource, 'to_pyinfra_assert_operations'):
                try:
                    assertions = resource.to_pyinfra_assert_operations()
                    if assertions.strip():
                        resource_ops.append(assertions)
                except Exception as e:
                    logger.warning(
                        f"Failed to generate assertions for {resource.name}: {e}"
                    )

            # Combine operations for this resource
            if len(resource_ops) > 1:  # More than just the comment
                all_operations.extend(resource_ops)

        # Combine all operations
        if all_operations:
            assert_code += "\n".join(all_operations)
        else:
            assert_code += "\n# No assertions defined\n"

        return assert_code
